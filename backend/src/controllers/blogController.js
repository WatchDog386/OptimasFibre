// backend/src/controllers/blogController.js

import BlogPost from '../models/BlogPost.js';
import mongoose from 'mongoose';
import PDFDocument from 'pdfkit';

/**
 * Fetch all blog posts (published, sorted by date)
 */
export const getAllBlogPosts = async (req, res) => {
  try {
    console.log('ðŸ“š Fetching all blog posts...');
    
    const posts = await BlogPost.find()
      .sort({ publishedAt: -1 })
      .select('-__v')
      .populate('author', 'email publicEmail role');

    res.status(200).json({
      success: true,
      count: posts.length,
      data: posts
    });
  } catch (err) {
    console.error('ðŸ“š Error fetching blog posts:', err.message);
    res.status(500).json({
      success: false,
      message: 'Unable to fetch blog posts'
    });
  }
};

/**
 * Fetch single blog post by ID or slug
 */
export const getBlogPostById = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Allow lookup by ID or slug
    const query = mongoose.Types.ObjectId.isValid(id) 
      ? { _id: id } 
      : { slug: id };

    const post = await BlogPost.findOne(query)
      .populate('author', 'email publicEmail role');

    if (!post) {
      return res.status(404).json({
        success: false,
        message: 'Blog post not found'
      });
    }

    res.status(200).json({
      success: true,
      data: post
    });
  } catch (err) {
    console.error('ðŸ“š Error fetching blog post:', err.message);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

/**
 * Generate PDF for a blog post
 */
export const generateBlogPDF = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find the blog post (same logic as getBlogPostById)
    let query;
    if (mongoose.Types.ObjectId.isValid(id)) {
      query = { _id: id };
    } else {
      query = { slug: id };
    }

    const post = await BlogPost.findOne(query);

    if (!post) {
      return res.status(404).json({
        success: false,
        message: 'Blog post not found'
      });
    }

    // Create PDF document
    const doc = new PDFDocument({
      size: 'A4',
      margins: { top: 60, bottom: 60, left: 60, right: 60 }
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    const filename = `${post.slug || 'blog-post'}.pdf`;
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

    // Pipe PDF to response
    doc.pipe(res);

    // Add title
    doc.fontSize(24).fillColor('#015B97').text(post.title, { align: 'center' });
    doc.moveDown(0.5);
    
    // Add metadata
    const date = new Date(post.publishedAt || post.createdAt).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    doc.fontSize(10).fillColor('#666').text(
      `Published: ${date} | Category: ${post.category || 'General'}`,
      { align: 'center' }
    );
    doc.moveDown(1.5);

    // Add content with proper line breaks
    const content = post.content || '';
    const paragraphs = content.split('\n').filter(p => p.trim() !== '');
    
    doc.fontSize(12).fillColor('#333');
    paragraphs.forEach((paragraph, index) => {
      if (index > 0) doc.moveDown(0.5);
      doc.text(paragraph.trim(), {
        width: 460,
        align: 'justify'
      });
    });

    doc.moveDown(2);
    doc.fontSize(10).fillColor('#999').text('Generated by Optimas Blog', { align: 'center' });

    // Finalize PDF
    doc.end();
  } catch (error) {
    console.error('ðŸ“š PDF generation error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to generate PDF'
    });
  }
};

/**
 * Create new blog post
 */
export const createBlogPost = async (req, res) => {
  try {
    const { title, content, imageUrl, category } = req.body;

    // Validate required fields
    if (!title || !content) {
      return res.status(400).json({
        success: false,
        message: 'Title and content are required'
      });
    }

    // Create post (slug will be auto-generated by model pre-save hook)
    const newPost = await BlogPost.create({
      title: title.trim(),
      content: content.trim(),
      imageUrl: imageUrl || '',
      category: category || 'General',
      author: req.user._id,
      publishedAt: req.body.publishedAt || new Date()
    });

    res.status(201).json({
      success: true,
      message: 'Blog post created successfully',
      data: newPost
    });
  } catch (err) {
    console.error('ðŸ“š Error creating blog post:', err.message);
    if (err.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        message: Object.values(err.errors).map(e => e.message).join(', ')
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

/**
 * Update blog post
 */
export const updateBlogPost = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, content, imageUrl, category, publishedAt } = req.body;

    if (!title || !content) {
      return res.status(400).json({
        success: false,
        message: 'Title and content are required'
      });
    }

    // Let model handle slug generation automatically on save
    const updateData = {
      title: title.trim(),
      content: content.trim(),
      imageUrl: imageUrl || '',
      category: category || 'General',
      publishedAt: publishedAt || undefined,
      updatedAt: new Date()
    };

    const updatedPost = await BlogPost.findByIdAndUpdate(
      id,
      updateData,
      { 
        new: true, 
        runValidators: true,
        context: 'query' 
      }
    ).populate('author', 'email publicEmail role');

    if (!updatedPost) {
      return res.status(404).json({
        success: false,
        message: 'Blog post not found'
      });
    }

    res.status(200).json({
      success: true,
      message: 'Blog post updated successfully',
      data: updatedPost
    });
  } catch (err) {
    console.error('ðŸ“š Error updating blog post:', err.message);
    if (err.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        message: Object.values(err.errors).map(e => e.message).join(', ')
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

/**
 * Delete blog post
 */
export const deleteBlogPost = async (req, res) => {
  try {
    const { id } = req.params;
    const deletedPost = await BlogPost.findByIdAndDelete(id);

    if (!deletedPost) {
      return res.status(404).json({
        success: false,
        message: 'Blog post not found'
      });
    }

    res.status(200).json({
      success: true,
      message: 'Blog post deleted successfully',
      data: deletedPost
    });
  } catch (err) {
    console.error('ðŸ“š Error deleting blog post:', err.message);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};